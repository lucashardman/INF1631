************* Relatorio *************

Alunos:
Stephanie Fay
Lucas Hardman

************* Exercicio 1 *************

a) Escreva o algoritmo resultante da prova acima

Como vimos no passo indutivos, xˆ(k + 1) - yˆ(k + 1) = (xˆk + y * q[k]) * (x - y) = q[k+1] * (x - y)
Cortando (x - y) ficamos com (xˆk + y * q[k]) = q[k+1], que equivale a q[k] = xˆ(k - 1) + y * q[k-1]

Transformando a formula para algoritmo:

inicio funcao quociente(x,y,k)

	se k == 1:
		entao returna 1
	returna x^(k-1) + (y * quociente(x,y,k-1))

fim funcao

onde o comando "returna x^(k-1) + (y * quociente(x,y,k-1))" corresponde a formula "q[k] = xˆ(k - 1) + y * q[k-1]", 
que é chamada recursivamente.

b) Implemente este algoritmo e teste para vários valores de x, y, e k.

def quociente(x,y,k):
	if k == 1:
		return 1
	return x^(k-1) + (y * quociente(x,y,k-1))

No programa teorema1.py primeiro é feito o caso base: q = (pow(x, 1) - pow(y, 1))/(x - y) = 1

Depois o usuario da valores para x, y e k para ver que qualquer valor que ele escolher, o
quociente será um valor inteiro, indicando a divisibilidade de (xˆk - yˆk) por (x - y)

Por fim, o programa faz um loop de duração de 5 segundos onde são gerados varios valores aleatorios
entre 1 e 100 para calcular quantas execucuções por segundo são feitas em média. Em um teste foram
gerados estes valores:

Execucoes: 57346
Tempo: 5.00004292 segundos
Execucoes por segundo: 11469.1016

************* Exercicio 2 *************
Teorema 2: O número de números inteiros cujos dígitos pertencem ao conjunto {1, 2, ..., m} de K dígitos diferentes é dado pelo produto m*(m-1)*...*(m-k+1).

a) Como o número não pode possuir dígitos repetidos, sabemos que m é sempre menor ou igual a k.

Caso Base: (k=1), para formar um número de um dígitos basta escolher um conjunto e este será o número, sendo assim podemos ter m números.

Passo Indutivo: Seja um número de k-1 dígitos com N possibilidades de ordem de formação, quando inserimos um novo dígito K ao final obtemos um número com K dígitos e N*(m-k+1) possibilidades para sua formação.

m - (k - 1) = m - k + 1
pela hipótese: N = m * (m - 1) * ... * (m - k + 2)
logo: m * (m - 1) * ... * (m - k + 2) * (m - k + 1)

b)

se k == 1:
   enquanto i >= m:
        novaLista = novaLista + Elemento [i+1]
    return novaLista

    ListaAntiga = func(k-1,m)

    Enquanto K está na lista:
       Enquanto aux >= m:
            se o aux+1 não está na ListaAntiga:
                novoNumero = ListaAntiga[K]
                novoNumero = NovoNumero + aux+1
                novaLista += novoNumero
    return novaLista

c)
m = 10
k = 4
Total: 10000
Execuções: 24
Tempo: 5.134s
Tempo por Execução: 213.925471ms

----------------------------------

m = 10
k = 1
Total: 10
Execuções: 1363313
Tempo: 5.001s
Tempo por Execução: 0.003668ms

[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]]

----------------------------------

m = 4
k = 3
Total: 64
Execuções: 49939
Tempo: 5.000s
Tempo por Execução: 0.100131ms

[[1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 1, 4], [1, 2, 1], [1, 2, 2], [1, 2, 3], [1, 2, 4], [1, 3, 1], [1, 3, 2], [1, 3, 3], [1, 3, 4], [1, 4, 1], [1, 4, 2], [1, 4, 3], [1, 4, 4], [2, 1, 1], [2, 1, 2], [2, 1, 3], [2, 1, 4], [2, 2, 1], [2, 2, 2], [2, 2, 3], [2, 2, 4], [2, 3, 1], [2, 3, 2], [2, 3, 3], [2, 3, 4], [2, 4, 1], [2, 4, 2], [2, 4, 3], [2, 4, 4], [3, 1, 1], [3, 1, 2], [3, 1, 3], [3, 1, 4], [3, 2, 1], [3, 2, 2], [3, 2, 3], [3, 2, 4], [3, 3, 1], [3, 3, 2], [3, 3, 3], [3, 3, 4], [3, 4, 1], [3, 4, 2], [3, 4, 3], [3, 4, 4], [4, 1, 1], [4, 1, 2], [4, 1, 3], [4, 1, 4], [4, 2, 1], [4, 2, 2], [4, 2, 3], [4, 2, 4], [4, 3, 1], [4, 3, 2], [4, 3, 3], [4, 3, 4], [4, 4, 1], [4, 4, 2], [4, 4, 3], [4, 4, 4]]


************* Exercicio 3 *************

Teorema 3: Sabe-se construir 2^k − 1 rodadas de 2ˆ(k − 1) jogos (cada rodada) onde cada equipe enfrenta uma
equipe diferente em cada rodada.

a) Apresente a prova por indução matemática no parâmetro k do Teorema 3

O número de equipes é n = 2ˆk.
O número de rodadas é r = 2ˆk-1.
O número de jogos por rodada é j = 2ˆ(k-1). 

Teorema do caso base: k = 1
	n = 2ˆ1 = 2.
	r = 2ˆ1 - 1 = 2 - 1 = 1.
	j = 2ˆ(1 - 1) = 2ˆ0 = 1.
	Ou seja, o caso base são duas equipes jogando uma rodada de um jogo.

Teorema do passo indutivo:
	Hipótese indutiva: assumimos que o teorema 3 é válido para um k qualquer.

	Queremos mostrar que o teorema também é válido para k + 1.
	Ou seja, n = 2ˆ(k+1),
			 r = 2ˆ(k+1)-1.
			 j = 2ˆ(k+1-1) = 2ˆk.

	Dividimos as equipes em dois grupos, A e B, de 2ˆk equipes cada.

	Na primeira etapa, tratamos cada grupo como torneios diferentes e ao mesmo tempo.
	Pela hipótese indutiva temos dois torneios, de 2ˆk - 1 rodadas cada e
	2ˆ(k-1) jogos. Como as rodadas de cada torneio sao simultaneas, temos ao todo
	2ˆk-1 rodadas com 2*(2ˆ(k-1))=2ˆk jogos cada.

	Ao fim da primeira etapa, todas equipes de A e B jogaram contra todas as outras equipes
	de seus respectivos grupos. Resta que cada equipe de A jogue contra cada equipe de B.

	Para a segunda etapa, vamos considerar o grupo A como uma fila e o grupo B como uma
	fila circular.

	A cada rodada da segunda etapa, a i-ésima equipe de A jogará contra a i-ésima equipe
	de B, para um total de 2ˆk jogos por rodada (afinal, A e B, cada um, tem 2ˆk equipes).
	Ao final de cada rodada, andamos uma posição na fila circular de B, e repetimos o processo
	até que voltemos à posiçao inicial de B. Nesse ponto, todas as equipes de A terao
	jogado contra todas as equipes de B. Observe que serao 2ˆk rodadas nessa segunda
	etapa (pois B tem 2ˆk posicoes/equipes).

	Assim, a primeira e segunda etapas juntas terao (2ˆk-1)+2ˆk=2ˆ(k+1)-1=r rodadas, com
	2ˆk=j jogos cada, como desejado.

b) Apresente o algoritmo correspondente à prova do Teorema 3 apresentada e a sua respectiva
implementação.

	i = 1
	se k = 1
		retorna i, i+1
	t1 = geraTorneio(k-1, i)
	t2 = geraTorneio(k-1, 2**(k-1)+i)

	enquanto t2
		t = t1[posicao] + t2[posicao]

	enquanto tamanho < length(times)
		enquanto index < length(times)
			index1 = index
			index2 = (index+tamanho)%length
			jogo = times[index1],times[index2]
			rodada += jogo
		t += rodada
	retorna t
	
		

c) Teste o algoritmo para valores de k. Qual o maior valor para o qual o seu algoritmo gera as
rodadas?

	13 rodadas.


